# 第0章 量子计算中的常用概念

### 什么是量子计算

在过去的几年中，出现了一系列新的计算机技术，其中量子计算可能是最需要开发者转变开发模式的技术。量子计算机是在上世纪80年代，由Richard Feynman和Yuri Manin提出的，但谈到量子计算，人么的印象往往来源于被视为物理学上的一个最大的尴尬：非凡的科学进展却对简单的系统无能为力。如你所见，早在1900~1925年间，量子力学的机理就已经被建立起来了，它是化学、凝聚态物理和从计算机芯片到LED照明再到其他技术的基石。尽管取得了很大的成就，但是利用量子力学去对一些非常简单的系统进行建模时仍然超出了人类的能力水平，这是因为即使是模拟几十个例子相互作用的系统，其所需要的计算能力也超过当今任何计算机持续计算数千年以上。

有多种方法可以理解量子力学为何难以模拟，最简单的方法就是将量子力学看做另一个问题。在量子水平上，同时存在着一系列可能的不同架构（也叫状态，量子态），不同于经典的概率论，这些可能被潜在观察到的状态可能会像水池中的波纹一样相互干扰，这种干扰阻碍了使用统计抽样来获取量子态的架构，并且，如果我们想要理解量子演进，那就必须追踪一个量子系统中所有的可能状态。

设想一个由电子组成的系统，其中电子可以出现在40个位置中的任何一个上，那么这个系统就存在$$2 ^ {40}$$种状态（每个位置上可能有也可能没有电子存在），在一个传统的计算机存储器上存储这些状态就需要130Gb的空间，对于如此大的存储当今的一些计算机还是可以满足的，但是如果将40变为41，多了一个位置造成的后果是存储空间要翻倍。如果我们继续按照常规办法这么做下去，这个增加位置的游戏马上就会进入死局，因为世界上最强大的存储设备也无法满足这样的指数增长。将电子数量扩大到数百个，那么所需要的内存甚至超过了宇宙中例子的数量，因此使用传统的计算机是无法模拟量子力学模型的。

这一问题引导着那修对量子计算有着早期愿景的人们思考这样一个问题：我们能否将这一挑战转变为一个机遇。量子力学难以模拟，那如果我们利用量子特性来建造硬件会发生什么呢？我们能否直接利用量子力学的机理来模拟相互作用的量子系统呢？我们是否可以研究在自然中不存在但遵循量子力学机制的任务呢？正事这些问题催生了量子计算。

量子计算的基础核心是是将信息存储在物质的量子态中，并使用量子门通过操控和学习给量子干涉编制程序来计算出信息。一个早期的利用对量子干涉编程来解决问题的例子是由 Peter Shor在1994年完成的，这是一个因式分解问题，对一个较大的数进行因式分解对传统计算机来说是困难的，解决因式分解问题能是现今电子商务安全基础上的许多公钥密码体制失效，例如RSA和ECDLP，到了那个时候，快速高效的量子算法被开发出来，能为我们解决许多经典计算机难以解决的难题：模拟化学、物理和材料科学中的物理系统，搜索无序数据库，求解线性方程组和机器学习等。

设计一个利用量子干涉的程序听起来像是一个艰巨的挑战，事实也确实如此，但目前已经有许多技术和工具包括微软的量子开发工具包被引入使量子程序和算法的开发更便捷。现实中有一些基本的对计算有用的策略可以被用来操控量子干涉，同时不会造成量子纠缠中的解丢失。量子编程是一种与经典编程截然不同的艺术，它需要用完全不同的工具去理解和表达量子编程思想，实际上，如果没有一般的工具来帮助开发者解决量子编程中的问题，量子程序的开发是一件不那么容易的事。

我们推出了微软量子程序开发工具包来推动正在成长的量子编程社区的发展，工具包中包含了为他们的任务、问题和解决方案解锁量子革命的工具。我们的高级程序语言Q\#旨在解决量子信息处理的挑战，它集成在一个软件栈中，使得量子算法能被编译成量子计算机的基本操作。在走进Q\#之前，回顾一下量子计算的基本原则是很有帮助的，在本书中，我们将把量子计算的基本规则作为公理，而不会详述量子力学的基础，并且我们假定读者有一定的线性代数基础（向量、矩阵等），如果你需要更深入地了解量子计算的历史和原理，请参考[https://docs.microsoft.com/zh-cn/quantum/quantum-formoreinfo?view=qsharp-preview。](https://docs.microsoft.com/zh-cn/quantum/quantum-formoreinfo?view=qsharp-preview。)

### 量子位

就像比特是经典计算中信息的基础对象，量子位是量子计算中信息的基础对象。为了理解这个对应关系，我们先来看最简单的单个量子位的情况。

#### 量子位的表示

一个比特的值可以是0或1，而一个量子位的值可以是0或1，也可以是这两个值的量子叠加，一个量子位的状态可以用一个二维的单位向量来描述，这个向量就叫做**量子态向量**，它保存了要描述一个单量子位量子系统状态所需要的全部信息。

任意一个范数为1的二维向量（无论是实数还是复数）都能表示一个量子位的状态，所以以下向量都属于量子态向量。

![](/Image/QuantumStateVector.png)

在所有量子态向量中，$$\begin{bmatrix} 1 \\  0 \end{bmatrix}$$和$$\begin{bmatrix} 0 \\  1 \end{bmatrix}$$ 有着特设的作用，这两个向量构成了描述量子状态的向量空间的基，这意味着任何一个量子态向量都可以用这两个基的和来表示，例如，向量$$\begin{bmatrix} x \\  y \end{bmatrix}$$ 可以写做$$x \begin{bmatrix} 1 \\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\  1 \end{bmatrix}$$ ，因此，这两个向量又被成为**计算基底**。

同时，我们将上述两个基所代表的量子态与经典计算中的比特位相对应，它们之间的转换关系为：

$$0\equiv \begin{bmatrix} 1 \\ 0 \end{bmatrix}\qquad 1 \equiv \begin{bmatrix} 0 \\ 1 \end{bmatrix}$$

#### 量子态的测量

我们已经知道了如何表示一个量子位，那么一个量子位的状态到底代表了什么呢？现在我们通过探讨量子态测量的概念来获取一个对量子态的认识。量子态的测量就是对量子状态的观察，根据量子力学的原理，观察一个量子会使其状态崩塌至两个基本状态$$\begin{bmatrix} 1 \\  0 \end{bmatrix}$$和$$\begin{bmatrix} 0 \\  1 \end{bmatrix}$$中的一个，当一个状态为$$\begin{bmatrix} \alpha \\  \beta \end{bmatrix}$$的量子被测量后，我们得到$$0$$的概率为$$\|\alpha\|^2$$，得到$$1$$的概率为$$\|\beta\|^2$$，并且$$\|\alpha\|^2 + \|\beta\|^2 = 1$$ 。根据上述量子态测量的性质，我们可以知道一个量子态矩阵与其符号是不相关的，这个向量与其反向量等价：$$\alpha \rightarrow -\alpha$$ , $$\beta \rightarrow -\beta$$ 。这是因为测量到$$0$$和$$1$$的概率取决于$$\alpha$$和$$\beta$$的平法的大小，在他们之前插入一个符号并不改变测量结果的概率分布。

有关测量的最后一个重要性质是测量并不会使所有量子态都发生改变。如果我们测量一个状态为$$\begin{bmatrix} 1 \\  0 \end{bmatrix}$$的量子，对应于经典计算中的比特$$0$$，那么我们得到的测量结果仍然为$$0$$，且量子本身的状态也不会改变。从这个意义上讲，如果我们只拥有经典的比特，那么我们对这些比特位进行测量也不会改变其状态，这也就意味着我们可以将经典计算的数据复制到量子计算机上，然后像在经典计算机上那样对其进行操作。

### 利用布罗兹球面可视化量子态和其转换

量子位也可以使用布罗兹球面3D化显示。布罗兹球面用三维的实值向量来描述单量子的量子态，如上所述，单个量子的状态由一个二维实值向量来描述。布罗兹球面使得一个量子的状态可视化，正因此，它在我们理解多量子状态时也有极大的作用。可视化的布罗兹球面如下所示：

![](/Image/BlochSphere.png)
	图0.1 布罗兹球面

图中的箭头指示了量子态向量的方向，箭头的每一次变换都可以看作是一个基本轴的旋转，那么自然而然我们可以将将量子态的变换看做是一系列的旋转变换，当然使用这种思想来设和描述量子算法也是一个不小的挑战，但Q\#为我们提供了能够方便地描述这些旋转操作的语言，从而简化了我们解决问题的负担。

### 单个量子位的操作

量子计算机通过应用一组能模拟量子态向量旋转的量子门来处理数据，量子门的概念与传统计算机中的门的概念类似，如果每一个输入比特的变换都可以用有限长度电路来执行，则门集被认为是通用的。

在量子计算中，我们能够在量子位上执行的合法的变换包括单一变化和测量。共轭操作也叫复共轭转置，他对量子计算有着至关重要的作用，因为在量子反转中需要用到它。Q\#通过自动将门序列编译到它们的共轭矩阵的方式来实现这一功能，将开发者从手工编码的泥潭中解放出来，大大减轻了开发者的负担。

在经典计算中，只有四种操作将一个比特映射到另一个比特（与、或、非、异或），但在量子计算机中，变换一个量子比特状态的操作是无穷的，因此在量子计算中，不存在一个有限的基本操作集合（门集合）能完全覆盖所允许的无穷的单一变换，这也意味着，量子计算机不可能像经典计算机那样使用有限的门操作来实现所有的量子算法，因此量子计算机不会像经典计算机一样通用。当我们谈到一个门集合对量子计算是通用的时候，我们实际要表达的意思要比完全通用弱化。对于通用性，我们要求量子计算机只在一个有限的误差内使用一个有限长的门序列来逼近某一幺正矩阵，或者说，只要任意的单一变换在误差允许范围内能够写作一个有限长的门操作序列的乘积，那么这个门集合就是通用的，如下所示：

$$G_N G_{N-1} \cdots G_2 G_1 \approx U.$$

注意因为矩阵乘法是从右向左计算的，因此上面公式中的$$G_{N}$$实际上是最后一个应用到的门操作。更正规地说，对于误差$$\epsilon > 0$$，存在$$G_1,\ldots, G_N$$使得$$G_N\ldots G_1$$ 和 $$U$$的误差不超过$$\epsilon$$，那么我们就说集合$$G_1,\ldots, G_N$$是通用的。

现实中，这样的通用门集合是什么样的呢？对单量子门而言，这样的集合中只包含两个门：Hadamard门（H门）和T门（也叫做$$\pi/8$$门）：  
$$H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 \\  1 &amp;-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 &amp; 0 \\  0 &amp; e^{i\pi/4} \end{bmatrix}.$$

但是考虑到量子就做的现实原因，一个更大的集合能够带来更多的便利，集合中其他的门可以有H和T门生成。我们将量子门分为两类：Clifford门和T门，这样分类是因为Clifford门在许多量子纠错方案中实现起来很方便，就操作和量子比特而言，他们需要很少的资源就能实现较好的容错率，然而非Clifford门的消耗就非常大了。在Q\#中，标准的单量子Clifford门包括：  
$$H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 \\  1 &amp;-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 &amp; 0 \\  0 &amp; i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &amp;1 \\  1&amp; 0 \end{bmatrix}= HT^4H,$$$$Y = \begin{bmatrix} 0 &amp; -i \\  i &amp; 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&amp;0\\ 0&amp;-1 \end{bmatrix}=T^4.$$

这些门中，X、Y和Z应用的非常广泛，它们也被成为Pauli操作符，这些门操作和非Clifford门一起就能组合出任意单一变换作用与单个量子上。下面的例子展示了如何用这些基本操作构建一个一元变换，图0.1中的三个变换对应于以下门操作序列：
$$\begin{bmatrix} 1 \\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\  0 \end{bmatrix} = \begin{bmatrix} 0 \\  1 \end{bmatrix}$$

前面的门操作在堆栈逻辑级别上构成了最基本的原语（逻辑级别等同与量子算法级别），但在算法级别较少地考虑基本操作会带来更大的便利，比如多使用近似函数级别的操作。幸运的是Q#中包含有很多用于实现高层次一元操作的方法，有了他们我们在实现更高层次的算法时就不需要将其分解为基本的Clifford和T门。

最简单的原语是单量子旋转操作。将三个单量子旋转用$$R_{x}$$、$$R_{y}$$和$$R_{z}$$表示，为了可视化旋转操作$$R_x(\theta)$$的行为，将右手大拇指指向布罗兹球面$$x$$轴的方向，然后右手旋转$$\theta/2$$弧度，相应的一元操作为：
$$R_z(\theta) = \begin{bmatrix} e^{-i\theta/2} &amp; 0\\  0&amp; e^{i\theta/2} \end{bmatrix},\qquad R_x(\theta) = H R_z(\theta) H, \qquad R_y(\theta) = SHR_z(\theta)HS^\dagger.$$

正如将任意三个旋转操作组合起来就能实现完成三维空间中的任意旋转，布罗兹球面所表示的任意幺正矩阵也能写成由三个旋转操作组成的序列，特别地，对每一个幺正矩阵$$U$$都有$$\alpha,\beta,\gamma,\delta$$使得$$U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$$。因此
